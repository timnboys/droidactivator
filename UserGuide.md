# Introduction #

DroidActivator is designed to:
  * block piracy by performing app activation on your remote server
  * manage application levels (sell app in different levels or configurations)
  * manage activation expiration (i.e. renewal, yearly fees)
  * track application usage (tracking of custom events)
  * acquire standard and custom info from devices

This guide is intended to provide some in-depth knowledge of the key concepts behind DroidActivator.

DroidActivator's system is composed by a MySql / Php backend where valid purchases along with activation data are stored, and an Android library acting as a bridge between the backend and the application.

DroidActivator's philosophy is to perform the activation in an unobtrusive and non-blocking way. User is asked to perform activation only when really needed, he is allowed to change the device and re-activate, to reinstall a fresh app and re-obtain his rights easily, and both the user and you have the time to manage the activation smoothly and with no hassle.

Only when all the time margins are gone, activation becomes mandatory, and even in that case, its up to you to decide what to do in case of activation failure (e.g. run in demo mode).

After the first activation, DroidActivator tries to sync activation data on the device at every start-up, allowing you to manage license expiration and application levels.

# Activation data #

Activation tracking on the device is controlled by some pieces of information kept in the backend and cached in the Shared Preferences of the device:

  * Activation Flag (boolean, initially false, becomes true the first time app is activated)
  * Expiration Date (long, represents the expiration date of the issued activation (0 if no expiration control is needed)
  * Application Level (int, the application level, usually 0 for demo 1 for base, 2 for pro and so forth...)
  * Unique id (calculated unique ID, identifying an installation/device combination)
  * User id (the User Id provided at the time of the last successful activation)

Master activation values are kept in the backend an can be changed by you at any time. Changes will be reflected in the application at next launch.

# Application Levels #

The features of an Application are represented by Levels. A level represents a specific configuration, which may include a group of features. It's up to the developer to configure the Levels as he needs. The developer is informed about the activation state and the current App Level, and is responsible to put in place the appropriate actions.

The Level represents what the user paid for and should get. For example, Level 0 can be Demo, Level 1 Base, Level 2 Pro and so forth. Or, you can combine different group of features in a Level, for example: Level 0 = Basic, Level 1 = Basic + feature A, Level 2 = Basic + feature B + feature C, Level 3 = Basic + feature A + feature C etc.

It is your responsibility to read the App Level and enable the corresponding features in your App.

The App Level is maintained in Shared Preferences and can be changed only by you on the backend.

# Application Activation #

The Activation represents an authorization to an Application to run at a given Level until a given Expiration date.

Activation data (activation flag, expiration date and app Level) is maintained in Shared Preferences and is overwritten on the device (with data from the backend) after each successful Activation Update.

# The Unique Id #

The App identifies itself to the backend using a special unique id. This id is calculated as a combination of an **Installation unique id** (generated by the Android Library on first run after installation and stored in the Shared Preferences) and a **Device unique id** (obtained on the fly from some specific device charachteristics).

These two ids are combined together to form an id **unique to the device/installation combination**. If the app is backed up and copied to another device, the device id part changes and the app must be re-activated. If the app is reinstalled on the same device, the installation id part changes and  the app must be re-activated.

So if i reset my device to factory defaults and sell it to someone, when he installs the app he has to activate it. If i make a backup of my installed app and give it to my friend, he also has to activate it. Of course, if i give away my registered email and code, anyone can download the app and activate it. But when i go back to use my app, my activation is “stolen” and i have to reactivate it, “stealing” back the activation and so on.

We suppose this is annoying enough to prevent most unauthorized usage. Maybe we implement in the backend some kind of activation swap control in the future.

# The Activation Cycle #

1) At startup (or when you decide to), your app calls an **Activation Cycle**.

This performs an **Activation Update** to sync cached activation data with backend data (cached activation data on device may change reflecting your backend data).

2) After the update (whether successful or not) an **Activation Check** is performed, and if the app is not activated the user is asked to supply activation data.

At this point the user can:

  * Supply data and confirm the activation
  * Cancel the activation process
  * Request a Temporary activation (for a limited time, and only if you enable this feature)

3) At the end of the Activation Cycle your app can access the new cached activation data and set up its behaviour accordingly.

## The Activation Update ##

The Activation Update process is performed at every startup, and consists in a call to the backend to read activation data and update cached data in the app. After an Activation Update, you can access updated data and set your app's behaviour accordingly.

The Activation Update is very fault-tolerant: it is performed in an unobtrusive way (only if connection is available, the backend is reachable, in a separate thread, and with short timeouts). The user should never be annoyed or even notice anything during an Activation Update.

If an Activation Update fails, nothing in the cached activation data is changed. This guarantees the customer retains his rights until an Update is successfully performed, so you can tear off your backend at any time with no hassle.

Yes, if the customers turns off networking at every startup or configures a firewall on the device after activation, he can avoid updates and still use your app indefinitely, avoiding the annual upgrade fee (if applicable). But we consider this a minor issue, compared to the advantage of managing an easily interruptible backend, and considering than one single update is enough to bring you control back over activation.

So, if network is found and everything else is ok, the Update is performed, and cached activation data may have changed.

For example, you could at any time change in the backend the app level or the expiration date based on an agreement with a single customer, or completely revoke an activation changing the activation flag. Be careful!

The Activation Update process is performed only after the first Activation.

In the Update process, the record is searched by Unique Id. If found, activation data in the device (activation flag, level, expiration) is updated from the backend and the update is finished.

If the Activation Record is not found by Unique Id, then it is searched by User Id.

If not found by Unique Id but found by User Id, then another installation has been activated with the same credentials (maybe the user reinstalled on the same device, or reinstalled on another device, or the credentials were stolen or given away and someone else activated the application using them). In this case, re-activation is requested, so we turn the Activation Flag off in the backend, and update device data (activation flag, level, expiration) so that In the subsequent Activation Check, the user will be requested to re-activate.

Applying this pattern, the last activated installation for a User  "steals" the activation to other installations of the same User, and so forth, every last user "steals" back the activation, so all users with the same credentials are requested to re-activate more or less each time they start the app. This can be annoying enough for our current goals. Maybe we'll implement some kind of license-swap limitation in the backend in the future.

If not found by Unique Id nor by User Id, the installation is not coupled to the backend. Maybe we didn't receive the purchase proof yet, or we deleted the Activation Record in the backend or the user is a really good hacker and he tampered with cached data. We can do nothing. Activation data will not be updated.

## The Activation Check ##

The Activation Check process verifies if an activation is needed and eventually starts the activation process.

An activation is always needed if the cached Activation flag is false.

In this case, the system tries to carry the activation out presenting the activation dialog to the user.

The information requested in the dialog always includes the activation code and may include or not the email address, depending on the possibility to couple the installation to the backend. Here we explain this better:

### The Unique Id is present in cached data ###
This means the app has been activated previously and if a re-activation is needed (and this is the case) it is because the activation has been for some reason revoked by you from the backend during a previous Update (probably the activation has expired, but it could have been manually revoked too, and the Activation Code on the backend has probably changed). Since the Unique Id is already cached, we expect to find a corresponding installation record in the backend.

So, we look for the Activation Record.

  * If we find it, everything is ok, we only need the activation code from the user, we check the code and if it is successful we update the cached activation data from the backend to the device.

  * If we don't find it, it's a data failure in the backend, maybe data got lost or corrupted. In this case it's our fault and we must provide a way to the user to re-activate. Provided we have fixed the problem in the backend and reloaded clean purchase data, we must re-identify the customer, so we also need the registered e-mail.

So, before presenting the activation dialog, we perform a check on the backend for the presence of the activation record by Unique Id. If the activation record is found, only the code is requested to the user. If the activation  record is not found, e-mail and code are requested. In the case the backend is unreachable, we assume the activation record will be found, don't ask for the e-mail, and delay the problem to the moment of the activation request (when the Activate button is pressed) which will fail if backend is not available or the activation record is not found.

### The Unique Id is not present in cached data ###

This means it is the first activation or a re-activation after a fresh reinstallation or a device change (when a device change is detected by DroidActivator, activation is revoked and Unique Id is wiped out to de-couple all existing installations from the Activation Record). We need to identify the customer again, so we need the registered e-mail address.

In both cases, for a limited time, the user has the option to perform a Temporary Activation if he didn't receive his code yet. To perform a Temporary activation, neither the code nor the e-mail is needed.

If an activation has been requested in the dialog, we check if the backend is reachable. In this case, an  Activation Request is sent to the backend. If the backend is not reachable, the user is alerted of the problem and asked to check the connection.

The request to the backend contains:

  * the App name (useful to manage multiple licensed apps on the same backend)
  * the Unique Id (from the cached data if present, otherwise calculated on the fly)
  * the User's e-mail address (if provided)
  * the Activation Code (as of received by email)

The backend validates the request by checking the app name and the activation code, and responds with a Success or Failure boolean and an error code.

If the response is True, the activation succeeded and the following actions are taken:

  * the Activated flag is set to True on the device and the backend
  * the Expiration Date on the device is set as returned by the backend
  * the Application Level on the device is set as returned by the backend
  * the Unique Id is written in the backend and cached in the device
  * the User Id (if provided) is cached in the device

If the response is False:

  * a failure message is displayed on the device, based on the failure code reported by the backend

## The temporary Activation ##
When the Activation dialog comes up, there is an option to perform a Temporary Activation.

This is intended to allow the user to use your app while he/she is waiting to receive from you the Activation Code (you have to receive proof of the purchase from the marketplace and load it to the backend first!).

This option will be available for a limited number of days since the first run (you configure it by calling DroidActivator.setMaximumActivationDelay()), then activation will become mandatory (the option is disabled and the user can only Confirm or Cancel the activation dialog).

If, after the time has expired, the user reinstalls a fresh copy of the application (therefore loosing all data!) the temporary activation option becomes available again. You can make this more annoying by specifying the time the user has to wait to press the “Later” button and have acces to your application. This is done by calling DroidActivator.setTemporaryWaitTime().

Anyway, be aware that enabling this option may permit an awkward but unlicensed usage of your app.

If a temporary activation has been issued,  DroidActivator.isActivated() returns true for the current app session, even if the activation flag is off in cached data. You can still check if this activation is temporary or final by calling **DroidActivator.isTemporarilyActivated()**.

The Temporary Activation feature is optional, it's enabled by default but you can disable it by calling DroidActivator.setTemporaryActivationAvailable(false).

# From the backend perspective #

## The Update request ##

The backend receives the update request along with the following parameters:

  * the cached Unique Id
  * the cached User Id

The Activation record is searched by Unique Id.

### Activation Record found by Unique Id ###

This is the standard situation. Send back Success code and data bundle. Activation parameters could be changed by the backend.

### Activation Record not found by Unique Id ###

The Activation record is searched by User Id.

  * If found, set the Activation flag off and clear the Unique Id in the Activation Record. Send send back success code and data bundle.

  * If not found, send back Failure code.


The data bundle returned in case of success contains:

  * Activation Flag
  * Expiration Date
  * Application Level

## The Activation request ##

The backend receives the activation request along with the following parameters:

  * the App Name (always present)
  * the User's e-mail address (if provided)
  * the Activation Code (always present)
  * the Unique Id (always present)

First, the Installation record is searched by Unique ID. If not found, it is searched by the couple User's e-mail address + App name.

### Found by Unique ID ###
This is a renewal. Check the Activation code.

  * Success: set the Activation flag to true, send back Success flag, Expiration Date, Application Level
  * Failure: send back Failure flag, Failure code.

### Found by User's e-mail address + App Name ###
This is a new activation: check the code and the app name

  * Success:  set the Activation flag to true, register the Unique id, send back Success flag, Expiration Date, Application Level.
  * Failure: send back  Failure flag, Failure code.

### Record not found ###
This is an attempt to activate the installation before purchase data is added to the backend. send back  Failure flag, Failure code.


# In your code #

These are the basic steps to integrate DroidActivator in your app:

1. As soon as you have a Context (usually in the onCreate() method) instantiate DroidActivator calling

```
DroidActivator.newInstance(context, backendAddress, runnable)
```

DroidActivator uses the Singleton pattern, so after instantiation you don't have to keep an instance and you make only static calls.

  * A `context` is needed for accessing Shared Preferences and resources, and to display the activation dialog.
  * `backendAddress` is a string representing the network address of your Php backend, in the form "http://151.10.128.32" or "http://droidactivator.mydomain.com".
  * the `runnable` is an object implementing the Runnable interface whose method run() will be called when the activation process is completed. In this run() method you start up your application.

2. Just after instantiation, you can configure the Activator (optional). Here you have the chance to change the default settings if needed.

For example:

```
DroidActivator.setTemporaryWaitTime(20);
```

3. Perform the Activation Cycle.

```
DroidActivator.doActivationCycle(context);
```

This will always try to update the cached Activation status based on your server data, and may bring up the Activation Dialog if needed (if the app is not activated or activation has expired). In any case, your Runnable will be called when the Activation Cycle is done and your app will always be started.


4. In your Activity, obtain the activation status from DroidActivator and put your actions in place.

For example, you may decide to start your app in demo mode, in full mode, or with a particular feature set based on the Activation Level, or to deny access completely.

To check if the installation is activated, you call **DroidActivator.isActivated()**. This method returns true also if the activation is temporary. If you need to distinguish between these cases, you can call **DroidActivator.isTemporarilyActivated()**. To check the activation level, call **DroidActivator.getLevel()**.

To use DroidActivator, your application requires the following permissions to be granted in the Manifest file:

```
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
<uses-permission android:name="android.permission.INTERNET" />
```

## An implementation example ##

There are many ways you can implement activation in your app. Here we suggest here a pattern which separates the activity where the activation is performed from the other activities of your app. This allows a better code separation and ensures the activation process is performed only once at startup.

1. Create an ActivationActivity and make it your main activity in your Manifest file, then implement the onCreate() and getContext() methods as follows:

### ActivationActivity class ###

```

@Override
public void onCreate(Bundle savedInstanceState) {
	
	super.onCreate(savedInstanceState);

	// instantiate DroidActivator
	DroidActivator.newInstance(this, "http://151.10.128.32", new Runnable() {

		// this method will be run when activation process is completed
		// your MainActivity will be started and the ActivationActivity will be finished
		public void run() {

			// start your Main Activity
			Intent intent = new Intent();
			intent.setClass(getContext(), MainActivity.class);
			startActivity(intent);

			// this will end ActivationActivity after starting your app
			// so it will be removed from the backstack
			finish();
		}
	});

	// optional: configure DroidActivator
	DroidActivator.setTemporaryWaitTime(3);

	// perform the Activation cycle - this may bring up the activation dialog
	DroidActivator.doActivationCycle(this);

}

/**
 * @return this activity's Context
 * (used to supply this context to the runnable's anonymous class)
 */
private Context getContext(){
	return this;
}

```

When the Activation Cycle is done, your MainActivity is started and the ActivationActivity is finished and will never be executed again.

2. In your MainActivity, check DroidActivator for the activation status and put the appropriate actions in place

### MainActivity class ###

```
@Override
public void onCreate(Bundle savedInstanceState) {

	super.onCreate(savedInstanceState);
			
	// test the activator variables and do whatever is appropriate	
	if (DroidActivator.isActivated()) {
		switch (DroidActivator.getLevel()) {
		case 0:
			startInDemoMode();
			break;
		case 1:
			startInBasicMode();
			break;
		case 2:
			startInProMode();
			break;
		}
	}
	else {
		askUserToPayAndExit();
	}
	
}

```

# Registering new purchases in the backend #

For the system to work, you have to mantain a registry of all the valid purchases.

Periodically, you obtain evidence of the new purchases from the Marketplace.

At this time, you have to add new VALID purchases to the Activation table of the database.
The following information is needed:

  * Customer email address
  * App Name (exactly as declared in the "android:label" attribute of your Android App's Manifest)
  * Activation Code (any random 8-digits number)

# Tracking custom events #

At any time you can make a call to the backend to track a particular event, passing to the backend an event code and a string containing custom data.

The App does not need to be activated for the event tracking system to work. You can track events before the activation, or for demo versions which will never be activated.

The event tracking is anonymous until the application is activated (you only know the installation's Unique Id). After the activation, also the User Id is known.

The call to the backend is performed in a separate thread with short timeouts. If the call fails because the backend is not reachable nothing happens and the user should not notice anything. Be aware that  this kind of event tracking is intended to be used for statistic purposes and it does not guarantee that all events will be tracked! Events are tracked only when the device has an active connection and the backend is up.

When the backend receives an Event Tracking request, it looks for the device's Activation Record by Unique Id. If found, it is used as the parent. If not found, a new Tracking Record record is created (an Activation Record without userId and with the TrackingOnly flag set to true) and used as parent.

Then a new Event Record is created as a child, and event data is stored in that record.

If an App requests activation after having been tracked for events, existing Event Records are associated to the Activation Record and the Tracking Record is deleted.

In your code, you send a Custom Event simply invoking:

```
DroidActivator.sendCustomEvent(eventCode, eventDetails);
```

Remember to instantiate DroidActivator somewhere before the call:

```
DroidActivator.newInstance(context, backendAddress, runnable);
```

If you don't need to activate your app but just want to use the event tracking feature, you can leave the runnable null. Also, in this case avoid to perform the call for the activation cycle!

# Acquiring device info #

At activation time, some standard device info (android version, screen size, resolution, and more) is acquired from the device and sent to the backend.

You can customize this information by extending `DroidActivator` class and overriding the `DroidActivator.createDeviceInfoMap()` method.

```
@Override
protected LinkedHashMap<String, String> createDeviceInfoMap(){

    //retrieve the info map already filled by the superclass 
    //(or create a new empty one if you are not interested in standard info)
    LinkedHashMap<String, String> map = super.createDeviceInfoMap(); 

    // add your own informations, key/value pairs
    map.put("myinfo", retrieveMyCustomInfo());

    // return the info map
    return map;
}
```